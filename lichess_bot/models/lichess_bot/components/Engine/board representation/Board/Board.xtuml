// BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

within lichess_bot::components::Engine::'board representation' is

	@key_letters("Board");
	@class_num(1);
	class Board is

		our_pawns: timestamp;

		our_knights: timestamp;

		our_bishops: timestamp;

		our_rooks: timestamp;

		our_queens: timestamp;

		our_king: timestamp;

		their_pawns: timestamp;

		their_knights: timestamp;

		their_bishops: timestamp;

		their_rooks: timestamp;

		their_queens: timestamp;

		their_king: timestamp;

		en_passant_target: timestamp;

		active_color: Color;

		we_can_castle_kingside: boolean;

		we_can_castle_queenside: boolean;

		they_can_castle_kingside: boolean;

		they_can_castle_queenside: boolean;

		half_move_clock: integer;

		full_move_number: integer;

		@dialect("oal");
		@operation_num(7);
		operation our_pieces_bitboard() return timestamp is
			@noparse
			return Bits::bitwise_or(a: self.our_pawns, b: Bits::bitwise_or(a: self.our_knights, b: Bits::bitwise_or(a: self.our_bishops, b: Bits::bitwise_or(a: self.our_rooks, b: Bits::bitwise_or(a: self.our_queens, b: self.our_king)))));
			@endnoparse
		end operation;

		@dialect("oal");
		@operation_num(7);
		operation their_pieces_bitboard() return timestamp is
			@noparse
			return Bits::bitwise_or(a: self.their_pawns, b: Bits::bitwise_or(a: self.their_knights, b: Bits::bitwise_or(a: self.their_bishops, b: Bits::bitwise_or(a: self.their_rooks, b: Bits::bitwise_or(a: self.their_queens, b: self.their_king)))));
			@endnoparse
		end operation;

		@dialect("oal");
		@operation_num(10);
		operation do_move(lan: in string) return instance of Board is
			@noparse
			// convert source and destination coordinates to bitboards
			src_bitboard = Bitboards::coordinate_to_bitboard(coordinate: STRING::substr(s: param.lan, begin: 0, end: 2));
			inverse_src_bitboard = Bits::bitwise_not(a: src_bitboard);
			dst_bitboard = Bitboards::coordinate_to_bitboard(coordinate: STRING::substr(s: param.lan, begin: 2, end: 4));
			inverse_dst_bitboard = Bits::bitwise_not(a: dst_bitboard);
			
			// get the promotion character
			promotion = "";
			if STRING::strlen(s: param.lan) > 4 then
				promotion = STRING::substr(s: param.lan, begin: 4, end: 5);
			end if;
			
			// check if this is a pawn move
			is_pawn_move = Bits::bitwise_and(a: src_bitboard, b: Bits::bitwise_or(a: self.our_pawns, b: self.their_pawns)) != 0;
			
			// check if the move is a capture
			is_capture = Bits::bitwise_and(a: self.their_pieces_bitboard(), b: dst_bitboard) != 0 or
				(is_pawn_move and Bits::bitwise_and(a: self.en_passant_target, b: dst_bitboard) != 0);
				
			// get a bitboard for the pawn captured en passant
			en_passant_captured_pawn = Bits::zero();
			if is_capture and Bits::bitwise_and(a: self.en_passant_target, b: dst_bitboard) != 0 then
				src_file_rank = Bitboards::bitboard_to_file_and_rank(bitboard: src_bitboard);
				dst_file_rank = Bitboards::bitboard_to_file_and_rank(bitboard: dst_bitboard);
				en_passant_captured_pawn =  Bits::left_shift(a: 1, n: src_file_rank[1] * 8 + dst_file_rank[0]);
			end if;
			
			// copy the piece bitboards and start changing them
			our_pawns = self.our_pawns;
			our_knights = self.our_knights;
			our_bishops = self.our_bishops;
			our_rooks = self.our_rooks;
			our_queens = self.our_queens;
			our_king = self.our_king;
			their_pawns = self.their_pawns;
			their_knights = self.their_knights;
			their_bishops = self.their_bishops;
			their_rooks = self.their_rooks;
			their_queens = self.their_queens;
			their_king = self.their_king;
			
			// if this is a castling move, update the position of the rook first
			if Bits::bitwise_and(a: our_king, b: src_bitboard) != 0 then
				src_file_rank = Bitboards::bitboard_to_file_and_rank(bitboard: src_bitboard);
				dst_file_rank = Bitboards::bitboard_to_file_and_rank(bitboard: dst_bitboard);
				if dst_file_rank[0] - src_file_rank[0] == 2 then     // kingside castle
					our_rooks = Bits::bitwise_and(a: our_rooks, b: Bits::bitwise_not(a: Bits::left_shift(a: src_bitboard, n: 3)));
					our_rooks = Bits::bitwise_or(a: our_rooks, b: Bits::unsigned_right_shift(a: dst_bitboard, n: 1));
				elif dst_file_rank[0] - src_file_rank[0] == -2 then  // queenside castle
					our_rooks = Bits::bitwise_and(a: our_rooks, b: Bits::bitwise_not(a: Bits::unsigned_right_shift(a: src_bitboard, n: 4)));
					our_rooks = Bits::bitwise_or(a: our_rooks, b: Bits::left_shift(a: dst_bitboard, n: 1));
				end if;
			end if;
			
			// vacate the source square and inhabit the destination square
			if Bits::bitwise_and(a: our_pawns, b: src_bitboard) != 0 then
				our_pawns = Bits::bitwise_and(a: our_pawns, b: inverse_src_bitboard);
				if promotion == "n" then
					our_knights = Bits::bitwise_or(a: our_knights, b: dst_bitboard);
				elif promotion == "b" then
					our_bishops = Bits::bitwise_or(a: our_bishops, b: dst_bitboard);
				elif promotion == "r" then
					our_rooks = Bits::bitwise_or(a: our_rooks, b: dst_bitboard);
				elif promotion == "q" then
					our_queens = Bits::bitwise_or(a: our_queens, b: dst_bitboard);
				else
					our_pawns = Bits::bitwise_or(a: our_pawns, b: dst_bitboard);
				end if;
			elif Bits::bitwise_and(a: our_knights, b: src_bitboard) != 0 then
				our_knights = Bits::bitwise_and(a: our_knights, b: inverse_src_bitboard);
				our_knights = Bits::bitwise_or(a: our_knights, b: dst_bitboard);
			elif Bits::bitwise_and(a: our_bishops, b: src_bitboard) != 0 then
				our_bishops = Bits::bitwise_and(a: our_bishops, b: inverse_src_bitboard);
				our_bishops = Bits::bitwise_or(a: our_bishops, b: dst_bitboard);
			elif Bits::bitwise_and(a: our_rooks, b: src_bitboard) != 0 then
				our_rooks = Bits::bitwise_and(a: our_rooks, b: inverse_src_bitboard);
				our_rooks = Bits::bitwise_or(a: our_rooks, b: dst_bitboard);
			elif Bits::bitwise_and(a: our_queens, b: src_bitboard) != 0 then
				our_queens = Bits::bitwise_and(a: our_queens, b: inverse_src_bitboard);
				our_queens = Bits::bitwise_or(a: our_queens, b: dst_bitboard);
			elif Bits::bitwise_and(a: our_king, b: src_bitboard) != 0 then
				our_king = Bits::bitwise_and(a: our_king, b: inverse_src_bitboard);
				our_king = Bits::bitwise_or(a: our_king, b: dst_bitboard);
			end if;
			
			// clear the destination square on opposite color bitboards
			their_pawns = Bits::bitwise_and(a: their_pawns, b: Bits::bitwise_and(a: inverse_dst_bitboard, b: Bits::bitwise_not(a: en_passant_captured_pawn)));
			their_knights = Bits::bitwise_and(a: their_knights, b: inverse_dst_bitboard);
			their_bishops = Bits::bitwise_and(a: their_bishops, b: inverse_dst_bitboard);
			their_rooks = Bits::bitwise_and(a: their_rooks, b: inverse_dst_bitboard);
			their_queens = Bits::bitwise_and(a: their_queens, b: inverse_dst_bitboard);
			
			// create a new board and flip the POV
			create object instance board of Board;
			board.our_pawns = their_pawns;
			board.our_knights = their_knights;
			board.our_bishops = their_bishops;
			board.our_rooks = their_rooks;
			board.our_queens = their_queens;
			board.our_king = their_king;
			board.their_pawns = our_pawns;
			board.their_knights = our_knights;
			board.their_bishops = our_bishops;
			board.their_rooks = our_rooks;
			board.their_queens = our_queens;
			board.their_king = our_king;
			
			// update en passant target
			board.en_passant_target = Bits::zero();
			if is_pawn_move then
				src_file_rank = Bitboards::bitboard_to_file_and_rank(bitboard: src_bitboard);
				dst_file_rank = Bitboards::bitboard_to_file_and_rank(bitboard: dst_bitboard);
				if dst_file_rank[1] - src_file_rank[1] == 2 then     // white pawn move: move the src bitboard up one rank by shifting to the left 8 bits
					board.en_passant_target = Bits::left_shift(a: src_bitboard, n: 8);
				elif dst_file_rank[1] - src_file_rank[1] == -2 then  // black pawn move: move the src bitboard down one rank by shifting to the right 8 bits
					board.en_passant_target = Bits::unsigned_right_shift(a: src_bitboard, n: 8);
				end if;
			end if;
			
			// set active color
			if self.active_color == Color::WHITE then
				board.active_color = Color::BLACK;
			else
				board.active_color = Color::WHITE;
			end if;
			
			// update castling rights
			board.we_can_castle_kingside = self.they_can_castle_kingside;
			board.we_can_castle_queenside = self.they_can_castle_queenside;
			board.they_can_castle_kingside = self.we_can_castle_kingside;
			board.they_can_castle_queenside = self.we_can_castle_queenside;
			bb = Bitboards::get_instance();
			if self.we_can_castle_kingside and Bits::bitwise_and(a: Bits::bitwise_or(a: self.our_king, b: Bits::bitwise_and(a: self.our_rooks, b: bb.FILES[7])), b: src_bitboard) != 0 then
				board.they_can_castle_kingside = false;
			end if;
			if self.we_can_castle_queenside and Bits::bitwise_and(a: Bits::bitwise_or(a: self.our_king, b: Bits::bitwise_and(a: self.our_rooks, b: bb.FILES[0])), b: src_bitboard) != 0 then
				board.they_can_castle_queenside = false;
			end if;
			if self.they_can_castle_kingside and Bits::bitwise_and(a: Bits::bitwise_and(a: self.their_rooks, b: bb.FILES[7]), b: dst_bitboard) != 0 then
				board.we_can_castle_kingside = false;
			end if;
			if self.they_can_castle_queenside and Bits::bitwise_and(a: Bits::bitwise_and(a: self.their_rooks, b: bb.FILES[0]), b: dst_bitboard) != 0 then
				board.we_can_castle_queenside = false;
			end if;
			
			// update half move clock
			if is_capture or is_pawn_move then
				board.half_move_clock = 0;
			else
				board.half_move_clock = self.half_move_clock + 1;
			end if;
			
			// update full move number
			if self.active_color == Color::BLACK then
				board.full_move_number = self.full_move_number + 1;
			else
				board.full_move_number = self.full_move_number;
			end if;
			
			return board;
			@endnoparse
		end operation;

		@dialect("oal");
		@operation_num(4);
		operation to_fen() return string is
			@noparse
			fen = "";
			
			// set up color bitboards
			white_pawns = self.our_pawns;
			white_knights = self.our_knights;
			white_bishops = self.our_bishops;
			white_rooks = self.our_rooks;
			white_queens = self.our_queens;
			white_king = self.our_king;
			black_pawns = self.their_pawns;
			black_knights = self.their_knights;
			black_bishops = self.their_bishops;
			black_rooks = self.their_rooks;
			black_queens = self.their_queens;
			black_king = self.their_king;
			if self.active_color != Color::WHITE then
				white_pawns = self.their_pawns;
				white_knights = self.their_knights;
				white_bishops = self.their_bishops;
				white_rooks = self.their_rooks;
				white_queens = self.their_queens;
				white_king = self.their_king;
				black_pawns = self.our_pawns;
				black_knights = self.our_knights;
				black_bishops = self.our_bishops;
				black_rooks = self.our_rooks;
				black_queens = self.our_queens;
				black_king = self.our_king;
			end if;
			
			// populate piece positions section
			rank_num = 7;
			while rank_num >= 0 loop
				
				file_num = 0;
				blank_square_count = 0;
				while file_num < 8 loop
					
					// populate the piece
					square = "";
					if Bits::bitwise_and(a: white_pawns, b:  Bits::left_shift(a: 1, n: rank_num * 8 + file_num)) != 0 then
						square = "P";
					elif Bits::bitwise_and(a: white_knights, b:  Bits::left_shift(a: 1, n: rank_num * 8 + file_num)) != 0 then
						square = "N";
					elif Bits::bitwise_and(a: white_bishops, b:  Bits::left_shift(a: 1, n: rank_num * 8 + file_num)) != 0 then
						square = "B";
					elif Bits::bitwise_and(a: white_rooks, b:  Bits::left_shift(a: 1, n: rank_num * 8 + file_num)) != 0 then
						square = "R";
					elif Bits::bitwise_and(a: white_queens, b:  Bits::left_shift(a: 1, n: rank_num * 8 + file_num)) != 0 then
						square = "Q";
					elif Bits::bitwise_and(a: white_king, b:  Bits::left_shift(a: 1, n: rank_num * 8 + file_num)) != 0 then
						square = "K";
					elif Bits::bitwise_and(a: black_pawns, b:  Bits::left_shift(a: 1, n: rank_num * 8 + file_num)) != 0 then
						square = "p";
					elif Bits::bitwise_and(a: black_knights, b:  Bits::left_shift(a: 1, n: rank_num * 8 + file_num)) != 0 then
						square = "n";
					elif Bits::bitwise_and(a: black_bishops, b:  Bits::left_shift(a: 1, n: rank_num * 8 + file_num)) != 0 then
						square = "b";
					elif Bits::bitwise_and(a: black_rooks, b:  Bits::left_shift(a: 1, n: rank_num * 8 + file_num)) != 0 then
						square = "r";
					elif Bits::bitwise_and(a: black_queens, b:  Bits::left_shift(a: 1, n: rank_num * 8 + file_num)) != 0 then
						square = "q";
					elif Bits::bitwise_and(a: black_king, b:  Bits::left_shift(a: 1, n: rank_num * 8 + file_num)) != 0 then
						square = "k";
					end if;
					
					if square != "" then
						if blank_square_count > 0 then
							fen = fen + STRING::itoa(i: blank_square_count);
							blank_square_count = 0;
						end if;
						fen = fen + square;
					else
						blank_square_count = blank_square_count + 1;
					end if;
					
					file_num = file_num + 1;
				end while;
			
				// add the blank space count if the rank doesn't end with a piece
				if blank_square_count > 0 then
					fen = fen + STRING::itoa(i: blank_square_count);
				end if;
			
				// add the rank ender
				if rank_num >= 1 then
					fen = fen + "/";
				end if;
				
				rank_num = rank_num - 1;
			end while;
			
			fen = fen + " ";
			
			// populate the active color
			if self.active_color == Color::WHITE then
				fen = fen + "w";
			else
				fen = fen + "b";
			end if;
			
			fen = fen + " ";
			
			// populate castling rights
			castling_rights = "";
			if (self.we_can_castle_kingside and self.active_color == Color::WHITE) or
					(self.they_can_castle_kingside and self.active_color == Color::BLACK) then
				castling_rights = castling_rights + "K";
			end if;
			if (self.we_can_castle_queenside and self.active_color == Color::WHITE) or
					(self.they_can_castle_queenside and self.active_color == Color::BLACK) then
				castling_rights = castling_rights + "Q";
			end if;
			if (self.we_can_castle_kingside and self.active_color == Color::BLACK) or
					(self.they_can_castle_kingside and self.active_color == Color::WHITE) then
				castling_rights = castling_rights + "k";
			end if;
			if (self.we_can_castle_queenside and self.active_color == Color::BLACK) or
					(self.they_can_castle_queenside and self.active_color == Color::WHITE) then
				castling_rights = castling_rights + "q";
			end if;
			if castling_rights != "" then
				fen = fen + castling_rights;
			else
				fen = fen + "-";
			end if;
			
			fen = fen + " ";
			
			// populate en passant target
			if self.en_passant_target != Bits::zero() then
				fen = fen + Bitboards::bitboard_to_coordinate(bitboard: self.en_passant_target);
			else
				fen = fen + "-";
			end if;
			
			fen = fen + " ";
			
			// populate half move clock
			fen = fen + STRING::itoa(i: self.half_move_clock);
			
			fen = fen + " ";
			
			// populate full move number
			fen = fen + STRING::itoa(i: self.full_move_number);
			
			return fen;
			@endnoparse
		end operation;

		@dialect("oal");
		@operation_num(5);
		operation print() is
			@noparse
			// set up color bitboards
			white_pawns = self.our_pawns;
			white_knights = self.our_knights;
			white_bishops = self.our_bishops;
			white_rooks = self.our_rooks;
			white_queens = self.our_queens;
			white_king = self.our_king;
			black_pawns = self.their_pawns;
			black_knights = self.their_knights;
			black_bishops = self.their_bishops;
			black_rooks = self.their_rooks;
			black_queens = self.their_queens;
			black_king = self.their_king;
			if self.active_color != Color::WHITE then
				white_pawns = self.their_pawns;
				white_knights = self.their_knights;
				white_bishops = self.their_bishops;
				white_rooks = self.their_rooks;
				white_queens = self.their_queens;
				white_king = self.their_king;
				black_pawns = self.our_pawns;
				black_knights = self.our_knights;
				black_bishops = self.our_bishops;
				black_rooks = self.our_rooks;
				black_queens = self.our_queens;
				black_king = self.our_king;
			end if;
			
			rank_num = 7;
			while rank_num >= 0 loop
				
				// print the rank separator
				LOG::LogInfo(message: "---------------------------------");
				
				line_string = "";
				file_num = 0;
				file_sep = "| ";
				while file_num < 8 loop
					
					// populate the square
					square = " ";
					
					if Bits::bitwise_and(a: white_pawns, b:  Bits::left_shift(a: 1, n: rank_num * 8 + file_num)) != 0 then
						square = "P";
					elif Bits::bitwise_and(a: white_knights, b:  Bits::left_shift(a: 1, n: rank_num * 8 + file_num)) != 0 then
						square = "N";
					elif Bits::bitwise_and(a: white_bishops, b:  Bits::left_shift(a: 1, n: rank_num * 8 + file_num)) != 0 then
						square = "B";
					elif Bits::bitwise_and(a: white_rooks, b:  Bits::left_shift(a: 1, n: rank_num * 8 + file_num)) != 0 then
						square = "R";
					elif Bits::bitwise_and(a: white_queens, b:  Bits::left_shift(a: 1, n: rank_num * 8 + file_num)) != 0 then
						square = "Q";
					elif Bits::bitwise_and(a: white_king, b:  Bits::left_shift(a: 1, n: rank_num * 8 + file_num)) != 0 then
						square = "K";
					elif Bits::bitwise_and(a: black_pawns, b:  Bits::left_shift(a: 1, n: rank_num * 8 + file_num)) != 0 then
						square = "p";
					elif Bits::bitwise_and(a: black_knights, b:  Bits::left_shift(a: 1, n: rank_num * 8 + file_num)) != 0 then
						square = "n";
					elif Bits::bitwise_and(a: black_bishops, b:  Bits::left_shift(a: 1, n: rank_num * 8 + file_num)) != 0 then
						square = "b";
					elif Bits::bitwise_and(a: black_rooks, b:  Bits::left_shift(a: 1, n: rank_num * 8 + file_num)) != 0 then
						square = "r";
					elif Bits::bitwise_and(a: black_queens, b:  Bits::left_shift(a: 1, n: rank_num * 8 + file_num)) != 0 then
						square = "q";
					elif Bits::bitwise_and(a: black_king, b:  Bits::left_shift(a: 1, n: rank_num * 8 + file_num)) != 0 then
						square = "k";
					elif Bits::bitwise_and(a: self.en_passant_target, b:  Bits::left_shift(a: 1, n: rank_num * 8 + file_num)) != 0 then
						square = "*";
					end if;
					
					// append the square
					line_string = line_string + file_sep + square;
					
					
					file_sep = " | ";
					file_num = file_num + 1;
				end while;
				
				// at the end of the rank append the final separator and rank number
				line_string = line_string + " | " + STRING::itoa(i: rank_num + 1);
				LOG::LogInfo(message: line_string);
				
				rank_num = rank_num - 1;
			end while;
			
			// at the end print the last rank separator and the file letters
			LOG::LogInfo(message: "---------------------------------");
			LOG::LogInfo(message: "  a   b   c   d   e   f   g   h");
			@endnoparse
		end operation;

		@dialect("oal");
		@operation_num(2);
		class operation from_fen(fen: in string) return instance of Board is
			@noparse
			create object instance board of Board;
			
			// initialize bitboards
			white_pawns = Bits::zero();
			white_knights = Bits::zero();
			white_bishops = Bits::zero();
			white_rooks = Bits::zero();
			white_queens = Bits::zero();
			white_king = Bits::zero();
			black_pawns = Bits::zero();
			black_knights = Bits::zero();
			black_bishops = Bits::zero();
			black_rooks = Bits::zero();
			black_queens = Bits::zero();
			black_king = Bits::zero();
			
			fen = param.fen;
			if fen == "startpos" then
				fen = startpos;
			end if;
			
			// add a space to the end of the FEN string for token parsing
			fen = fen + " ";
			
			// split the FEN into space delimited tokens
			token_num = 0;
			i = 0;
			token_end = STRING::indexof( haystack: STRING::substr(s: fen, begin: i, end: -1), needle: " ");
			while token_end != -1 loop
				token = STRING::substr(s: fen, begin: i, end: i + token_end);
				
				// parse the piece positions
				if token_num == 0 then
				
					rank_num = 7;
					a = 0;
					b = STRING::indexof(haystack: STRING::substr(s: token, begin: a, end: -1), needle: "/");
					rank = STRING::substr(s: token, begin: a, end: b);
					while rank_num >= 0 loop  // loop through each rank
			
						// loop through each character
						j = 0;
						file_num = 0;
						while j < STRING::strlen(s: rank) loop  // loop through each file
							character = STRING::substr(s: rank, begin: j, end: j + 1);
							if character == "P" then
								white_pawns = Bits::bitwise_or(a: white_pawns, b: Bits::left_shift(a: 1, n: 8 * rank_num + file_num));
							elif character == "N" then
								white_knights = Bits::bitwise_or(a: white_knights, b: Bits::left_shift(a: 1, n: 8 * rank_num + file_num));
							elif character == "B" then
								white_bishops = Bits::bitwise_or(a: white_bishops, b: Bits::left_shift(a: 1, n: 8 * rank_num + file_num));
							elif character == "R" then
								white_rooks = Bits::bitwise_or(a: white_rooks, b: Bits::left_shift(a: 1, n: 8 * rank_num + file_num));
							elif character == "Q" then
								white_queens = Bits::bitwise_or(a: white_queens, b: Bits::left_shift(a: 1, n: 8 * rank_num + file_num));
							elif character == "K" then
								white_king = Bits::bitwise_or(a: white_king, b: Bits::left_shift(a: 1, n: 8 * rank_num + file_num));
							elif character == "p" then
								black_pawns = Bits::bitwise_or(a: black_pawns, b: Bits::left_shift(a: 1, n: 8 * rank_num + file_num));
							elif character == "n" then
								black_knights = Bits::bitwise_or(a: black_knights, b: Bits::left_shift(a: 1, n: 8 * rank_num + file_num));
							elif character == "b" then
								black_bishops = Bits::bitwise_or(a: black_bishops, b: Bits::left_shift(a: 1, n: 8 * rank_num + file_num));
							elif character == "r" then
								black_rooks = Bits::bitwise_or(a: black_rooks, b: Bits::left_shift(a: 1, n: 8 * rank_num + file_num));
							elif character == "q" then
								black_queens = Bits::bitwise_or(a: black_queens, b: Bits::left_shift(a: 1, n: 8 * rank_num + file_num));
							elif character == "k" then
								black_king = Bits::bitwise_or(a: black_king, b: Bits::left_shift(a: 1, n: 8 * rank_num + file_num));
							else
								// consecutive blank spaces denoted by a number
								file_num = file_num + STRING::atoi(s: character) - 1;
							end if;
							
							file_num = file_num + 1;
							j = j + 1;
						end while;
			
						// get the next rank
						a = b + 1;
						if rank_num > 1 then
							b = a + STRING::indexof(haystack: STRING::substr(s: token, begin: a, end: -1), needle: "/");
						else
							b = -1;
						end if;
						rank = STRING::substr(s: token, begin: a, end: b);
						
						rank_num = rank_num - 1;
					end while;
					
				// parse active color
				elif token_num == 1 then
					
					if token == "w" then
						board.active_color = Color::WHITE;
					else
						board.active_color = Color::BLACK;
					end if;
					
				// parse castling rights
				elif token_num == 2 then
					
					if token != "-" then
						white_can_castle_kingside = STRING::indexof(haystack: token, needle: "K") != -1;
						white_can_castle_queenside = STRING::indexof(haystack: token, needle: "Q") != -1;
						black_can_castle_kingside = STRING::indexof(haystack: token, needle: "k") != -1;
						black_can_castle_queenside = STRING::indexof(haystack: token, needle: "q") != -1;
						board.we_can_castle_kingside = (board.active_color == Color::WHITE and white_can_castle_kingside) or (board.active_color == Color::BLACK and black_can_castle_kingside);
						board.we_can_castle_queenside = (board.active_color == Color::WHITE and white_can_castle_queenside) or (board.active_color == Color::BLACK and black_can_castle_queenside);
						board.they_can_castle_kingside = (board.active_color == Color::WHITE and black_can_castle_kingside) or (board.active_color == Color::BLACK and white_can_castle_kingside);
						board.they_can_castle_queenside = (board.active_color == Color::WHITE and black_can_castle_queenside) or (board.active_color == Color::BLACK and white_can_castle_queenside);
					end if;
			
				// parse en passant target
				elif token_num == 3 then
					
					if token != "-" then
						board.en_passant_target = Bitboards::coordinate_to_bitboard(coordinate: token);
					end if;
					
				// parse half move clock
				elif token_num == 4 then
					
					board.half_move_clock = STRING::atoi(s: token);
			
				// parse full move number
				elif token_num == 5 then
			
					board.full_move_number = STRING::atoi(s: token);
				
				end if;
				
				token_num = token_num + 1;
				i = i + token_end + 1;
				token_end = STRING::indexof( haystack: STRING::substr(s: fen, begin: i, end: -1), needle: " ");
			end while;
			
			// copy the bitboards based on active color
			if board.active_color == Color::WHITE then
				board.our_pawns = white_pawns;
				board.our_knights = white_knights;
				board.our_bishops = white_bishops;
				board.our_rooks = white_rooks;
				board.our_queens = white_queens;
				board.our_king = white_king;
				board.their_pawns = black_pawns;
				board.their_knights = black_knights;
				board.their_bishops = black_bishops;
				board.their_rooks = black_rooks;
				board.their_queens = black_queens;
				board.their_king = black_king;
			else
				board.our_pawns = black_pawns;
				board.our_knights = black_knights;
				board.our_bishops = black_bishops;
				board.our_rooks = black_rooks;
				board.our_queens = black_queens;
				board.our_king = black_king;
				board.their_pawns = white_pawns;
				board.their_knights = white_knights;
				board.their_bishops = white_bishops;
				board.their_rooks = white_rooks;
				board.their_queens = white_queens;
				board.their_king = white_king;
			end if;
			
			return board;
			@endnoparse
		end operation;

	end class;

end;
