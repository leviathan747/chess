// BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

within lichess_bot::components::Engine::games is

	@key_letters("Engine");
	@class_num(3);
	class 'Evaluation Engine' is

		//! TODO Eventually this will be a constant time map between FEN and instances of position that have already been evaluated
		evaluated_positions_map: integer;

		positions_evaluated: integer;

		@dialect("oal");
		@operation_num(4);
		operation dispose() is
			@noparse
			select any positionR4 related by self->Position[R4];
			while not empty positionR4 loop
				unrelate self from positionR4 across R4;
				positionR4.dispose();
				select any positionR4 related by self->Position[R4];
			end while;
			
			select one gameR1 related by self->ActiveGame[R1];
			if not empty gameR1 then
				unrelate self from gameR1 across R1;
				gameR1.dispose();
			end if;
			
			delete object instance self;
			@endnoparse
		end operation;

		@dialect("oal");
		@operation_num(2);
		operation analyze_lines(position: in instance of Position, depth: in integer, line: in string) is
			@noparse
			position = param.position;
			if param.depth == 0 then
			
				// this is the final position in the line, so we evaluate it
				position.evaluate();
			
				// TODO
				// LOG::LogInfo(message: "Analyzed line: " + param.line + " = " + STRING::itoa(i: position.evaluation));
			
			// analyze deeper and update this evaluation based on future positions
			else
			
				// create and prioritize the legal moves which follow this position
				position.create_next_moves();
			
				select one board related by position->Board[R6];
			
				// TODO evaluate moves in priority order
				select many next_moves related by position->Move[R2.'is follwed by'];
				for each next_move in next_moves loop
					
					// analyze the next position
					select one next_position related by next_move->Position[R2.'is follwed by'];
					self.analyze_lines(position: next_position, depth: param.depth - 1, line: param.line + " " + next_move.lan);
					
					// compare to find the best next move
					select one best_next_move related by position->Move[R5];
					if empty best_next_move or ( board.active_color == Color::WHITE and next_position.evaluation > position.evaluation ) or
							( board.active_color == Color::BLACK and next_position.evaluation < position.evaluation ) then
						if not empty best_next_move then
							unrelate best_next_move from position across R5;
						end if;
						relate next_move to position across R5;
						// TODO
						// LOG::LogInfo(message: "New best line: " + param.line + " " + next_move.lan + " : " + STRING::itoa(i: position.evaluation) + " -> " + STRING::itoa(i: next_position.evaluation));
						position.evaluation = next_position.evaluation;
						position.evaluation_depth = next_position.evaluation_depth + 1;
					end if;
				
					// TODO prune the tree using alpha-beta pruning; for now, evaluate the whole tree
			
				end for;
				
				// check for checkmate
				// TODO this also rewards stalemate
				if empty next_moves then
					if board.active_color == Color::WHITE then
						position.evaluation = MIN_EVAL;
					else
						position.evaluation = MAX_EVAL;
					end if;
				end if;
				
				/* TODO
				if not empty next_moves then
					select one best_next_move related by position->Move[R5];
					LOG::LogInfo(message: "Best line: " + param.line + " " + best_next_move.lan + " : " + STRING::itoa(i: position.evaluation));
				end if;
				*/
				
			end if;
			@endnoparse
		end operation;

	end class;

end;
