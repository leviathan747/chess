// BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

within lichess_bot::components::Engine::games is

	@key_letters("Position");
	@class_num(4);
	class Position is

		fen: string;

		evaluation: real;

		//! This attribute represents the depth to which the position has been analyzed.
		//! A non-negative value means the position has been evaluated.
		//! A value of 0 means the position itself has been evaluated.
		//! A value > 0 indicates the position has been evaluated considering future moves to the depth specified.
		evaluation_depth: integer = -1;

		@dialect("oal");
		evaluated: boolean is
			@noparse
			self.evaluated = self.evaluation_depth != -1;
			@endnoparse
		end;

		next_moves_created: boolean;

		preferred identifier is (fen);

		@dialect("oal");
		@operation_num(1);
		operation evaluate() is
			@noparse
			if not self.evaluated then
				
				// Count up total material on each side (measured in centipawns)
				// The evaluation is the difference in material
				//   pawn   = 100
				//   knight = 300
				//   bishop = 300
				//   rook   = 500
				//   queen  = 900
			
				select one board related by self->Board[R6];
			
				evaluation = 0;
				
				evaluation = evaluation + 100 * Board::bitboard_population(bitboard: board.white_pawns);
				evaluation = evaluation + 300 * Board::bitboard_population(bitboard: board.white_knights);
				evaluation = evaluation + 300 * Board::bitboard_population(bitboard: board.white_bishops);
				evaluation = evaluation + 500 * Board::bitboard_population(bitboard: board.white_rooks);
				evaluation = evaluation + 900 * Board::bitboard_population(bitboard: board.white_queens);
			
				evaluation = evaluation - 100 * Board::bitboard_population(bitboard: board.black_pawns);
				evaluation = evaluation - 300 * Board::bitboard_population(bitboard: board.black_knights);
				evaluation = evaluation - 300 * Board::bitboard_population(bitboard: board.black_bishops);
				evaluation = evaluation - 500 * Board::bitboard_population(bitboard: board.black_rooks);
				evaluation = evaluation - 900 * Board::bitboard_population(bitboard: board.black_queens);
			
				self.evaluation = evaluation;
				self.evaluation_depth = 0;
				select one engine related by self->Engine[R4];
			
				engine.positions_evaluated = engine.positions_evaluated + 1;
			
			end if;
			@endnoparse
		end operation;

		@dialect("oal");
		@operation_num(3);
		operation create_next_moves() is
			@noparse
			// create and categorize future moves
			if not self.next_moves_created then
			
				select one engine related by self->Engine[R4];
				
				// get the list of legal next moves
				legal_moves = ChessLib::legalMoves(fen: self.fen);
				
				i = 0;
				max_next_moves = Bot::getInteger(name:"debug_max_next_moves", default_value: -1);
				while i < legal_moves.length and (max_next_moves == -1 or i < max_next_moves) loop
					move_lan = legal_moves[i];
					
					select any move related by self->Move[R2.'is follwed by'] where selected.lan == move_lan;
					if empty move then
						move = self.new_move(lan: move_lan);
					end if;
			
					i = i + 1;
				end while;
				
				self.next_moves_created = true;
			
			end if;
			@endnoparse
		end operation;

		@dialect("oal");
		@operation_num(4);
		operation dispose() is
			@noparse
			select one moveR5 related by self->Move[R5];
			if not empty moveR5 then
				unrelate self from moveR5 across R5;
			end if;
			
			select one moveR2_1 related by self->Move[R2.'follows'];
			if not empty moveR2_1 then
				select one positionR2_1 related by moveR2_1->Position[R2.'follows'];
				unrelate self from positionR2_1 across R2.'follows' using moveR2_1;
				delete object instance moveR2_1;
			end if;
			
			select any moveR2_2 related by self->Move[R2.'is follwed by'];
			while not empty moveR2_2 loop
				select one positionR2_2 related by moveR2_2->Position[R2.'is follwed by'];
				unrelate self from positionR2_2 across R2.'is follwed by' using moveR2_2;
				delete object instance moveR2_2;
				positionR2_2.dispose();
				select any moveR2_2 related by self->Move[R2.'is follwed by'];
			end while;
			
			select one engineR4 related by self->Engine[R4];
			if not empty engineR4 then
				unrelate self from engineR4 across R4;
			end if;
			
			select one gameR3 related by self->ActiveGame[R3];
			if not empty gameR3 then
				unrelate self from gameR3 across R3;
			end if;
			
			select one boardR6 related by self->Board[R6];
			if not empty boardR6 then
				unrelate self from boardR6 across R6;
				delete object instance boardR6;
			end if;
			
			delete object instance self;
			@endnoparse
		end operation;

		@dialect("oal");
		@operation_num(5);
		operation new_move(lan: in string) return instance of Move is
			@noparse
			// create a new move
			create object instance move of Move;
			move.lan = param.lan;
			
			// create the new board
			select one current_board related by self->Board[R6];
			board = current_board.do_move(lan: move.lan);
			
			// TODO populate properties of the move
			// TODO Consider possible optimization: is this necessary if the move is being created after the fact
			
			// TODO in the future, we will want to detect if a position already exists
			// create the new position
			create object instance new_position of Position;
			moves[0] = param.lan;
			new_position.fen = board.to_fen();
			relate board to new_position across R6;
			select one engine related by self->Engine[R4];
			relate new_position to engine across R4;
			
			// link the new position in the tree
			relate new_position to self across R2.'follows' using move;
			
			return move;
			@endnoparse
		end operation;

	end class;

end;
