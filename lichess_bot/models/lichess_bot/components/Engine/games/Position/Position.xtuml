// BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

within lichess_bot::components::Engine::games is

	@key_letters("Position");
	@class_num(4);
	class Position is

		fen: string;

		color_to_move: Color;

		evaluation: real;

		//! This attribute represents the depth to which the position has been analyzed.
		//! A non-negative value means the position has been evaluated.
		//! A value of 0 means the position itself has been evaluated.
		//! A value > 0 indicates the position has been evaluated considering future moves to the depth specified.
		evaluation_depth: integer = -1;

		@dialect("oal");
		evaluated: boolean is
			@noparse
			self.evaluated = self.evaluation_depth != -1;
			@endnoparse
		end;

		next_moves_created: boolean;

		preferred identifier is (fen);

		@dialect("oal");
		@operation_num(1);
		operation evaluate() is
			@noparse
			if not self.evaluated then
				
				// Count up total material on each side (measured in centipawns)
				//   pawn   = 100
				//   knight = 300
				//   bishop = 300
				//   rook   = 500
				//   queen  = 900
			
				white_total_material = 0;
				black_total_material = 0;
			
				end_index = STRING::indexof(haystack: self.fen, needle: " ");
				rank_num = 7;
				a = 0;
				b = STRING::indexof(haystack: STRING::substr(s: self.fen, begin: a, end: -1), needle: "/");
				rank = STRING::substr(s: self.fen, begin: a, end: b);
				while rank_num >= 0 loop  // loop through each rank
			
					// loop through each character
					j = 0;
					file_num = 0;
					while j < STRING::strlen(s: rank) loop  // loop through each file
						character = STRING::substr(s: rank, begin: j, end: j + 1);
						weight = 0;
						is_white = true;
						if character == "P" then
							weight = 100;
						elif character == "N" or character == "B" then
							weight = 300;
						elif character == "R" then
							weight = 500;
						elif character == "Q" then
							weight = 900;
						elif character == "K" then
							white_king_rank = rank_num;
							white_king_file = file_num;
						elif character == "p" then
							weight = -100;
							is_white = false;
						elif character == "n" or character == "b" then
							weight = -300;
							is_white = false;
						elif character == "r" then
							weight = -500;
							is_white = false;
						elif character == "q" then
							weight = -900;
							is_white = false;
						elif character == "k" then
							black_king_rank = rank_num;
							black_king_file = file_num;
							is_white = false;
						else
							// consecutive blank spaces denoted by a number
							file_num = file_num + STRING::atoi(s: character) - 1;
						end if;
						if is_white then
							white_total_material = white_total_material + weight;
						else
							black_total_material = black_total_material + weight;
						end if;
						
						j = j + 1;
					end while;
			
					// get the next rank
					a = b + 1;
					if rank_num > 1 then
						b = a + STRING::indexof(haystack: STRING::substr(s: self.fen, begin: a, end: -1), needle: "/");
					else
						b = a + STRING::indexof(haystack: STRING::substr(s: self.fen, begin: a, end: -1), needle: " ");
					end if;
					rank = STRING::substr(s: self.fen, begin: a, end: b);
					
					rank_num = rank_num - 1;
				end while;
			
				// the evaluation is the difference in material with bonus applied calculated in centipawns
				self.evaluation = white_total_material + black_total_material;
				self.evaluation_depth = 0;
				select one engine related by self->Engine[R4];
			
				engine.positions_evaluated = engine.positions_evaluated + 1;
			
			end if;
			@endnoparse
		end operation;

		@dialect("oal");
		@operation_num(2);
		operation analyze_lines(depth: in integer, line: in string) is
			@noparse
			// evaluate this position in its own right
			self.evaluate();
			
			// analyze deeper and update this evaluation based on future positions
			if param.depth > 0 then
			
				// create and prioritize the legal moves which follow this position
				self.create_next_moves();
				
			
				// TODO evaluate moves in priority order
				select many next_moves related by self->Move[R2.'is follwed by'];
				for each next_move in next_moves loop
					
					// analyze the next position
					select one next_position related by next_move->Position[R2.'is follwed by'];
					next_position.analyze_lines(depth: param.depth - 1, line: param.line + " " + next_move.lan);
					
					// compare to find the best next move
					select one best_next_move related by self->Move[R5];
					if empty best_next_move or ( self.color_to_move == Color::WHITE and next_position.evaluation > self.evaluation ) or
							( self.color_to_move == Color::BLACK and next_position.evaluation < self.evaluation ) then
						if not empty best_next_move then
							unrelate best_next_move from self across R5;
						end if;
						relate next_move to self across R5;
						// TODO
						// LOG::LogInfo(message: "New best line: " + param.line + " " + next_move.lan + " : " + STRING::itoa(i: self.evaluation) + " -> " + STRING::itoa(i: next_position.evaluation));
						self.evaluation = next_position.evaluation;
						self.evaluation_depth = next_position.evaluation_depth + 1;
					end if;
				
					// TODO prune the tree using alpha-beta pruning; for now, evaluate the whole tree
			
				end for;
				
				// check for checkmate
				// TODO this also rewards stalemate
				if empty next_moves then
					if self.color_to_move == Color::WHITE then
						self.evaluation = MIN_EVAL;
					else
						self.evaluation = MAX_EVAL;
					end if;
				end if;
				
				/* TODO
				if not empty next_moves then
					select one best_next_move related by self->Move[R5];
					LOG::LogInfo(message: "Best line: " + param.line + " " + best_next_move.lan + " : " + STRING::itoa(i: self.evaluation));
				end if;
				*/
				
			else
				
				// TODO
				// LOG::LogInfo(message: "Analyzed line: " + param.line + " = " + STRING::itoa(i: self.evaluation));
			
			end if;
			@endnoparse
		end operation;

		@dialect("oal");
		@operation_num(3);
		operation create_next_moves() is
			@noparse
			// create and categorize future moves
			if not self.next_moves_created then
			
				select one engine related by self->Engine[R4];
				
				// get the list of legal next moves
				legal_moves = ChessLib::legalMoves(fen: self.fen);
				
				i = 0;
				max_next_moves = Bot::getInteger(name:"debug_max_next_moves", default_value: -1);
				while i < legal_moves.length and (max_next_moves == -1 or i < max_next_moves) loop
					move_lan = legal_moves[i];
					
					select any move related by self->Move[R2.'is follwed by'] where selected.lan == move_lan;
					if empty move then
						move = self.new_move(lan: move_lan);
					end if;
			
					i = i + 1;
				end while;
				
				self.next_moves_created = true;
			
			end if;
			@endnoparse
		end operation;

		@dialect("oal");
		@operation_num(4);
		operation dispose() is
			@noparse
			select one moveR5 related by self->Move[R5];
			if not empty moveR5 then
				unrelate self from moveR5 across R5;
			end if;
			
			select one moveR2_1 related by self->Move[R2.'follows'];
			if not empty moveR2_1 then
				select one positionR2_1 related by moveR2_1->Position[R2.'follows'];
				unrelate self from positionR2_1 across R2.'follows' using moveR2_1;
				delete object instance moveR2_1;
			end if;
			
			select any moveR2_2 related by self->Move[R2.'is follwed by'];
			while not empty moveR2_2 loop
				select one positionR2_2 related by moveR2_2->Position[R2.'is follwed by'];
				unrelate self from positionR2_2 across R2.'is follwed by' using moveR2_2;
				delete object instance moveR2_2;
				positionR2_2.dispose();
				select any moveR2_2 related by self->Move[R2.'is follwed by'];
			end while;
			
			select one engineR4 related by self->Engine[R4];
			if not empty engineR4 then
				unrelate self from engineR4 across R4;
			end if;
			
			select one gameR3 related by self->ActiveGame[R3];
			if not empty gameR3 then
				unrelate self from gameR3 across R3;
			end if;
			
			delete object instance self;
			@endnoparse
		end operation;

		@dialect("oal");
		@operation_num(5);
		operation new_move(lan: in string) return instance of Move is
			@noparse
			// create a new move
			create object instance move of Move;
			move.lan = param.lan;
			// TODO populate properties of the move
			// TODO Consider possible optimization: is this necessary if the move is being created after the fact
			
			// TODO in the future, we will want to detect if a position already exists
			// create the new position
			create object instance new_position of Position;
			moves[0] = param.lan;
			new_position.fen = ChessLib::movesToFEN(initialFen: self.fen, moves: moves);
			if self.color_to_move == Color::WHITE then
				new_position.color_to_move = Color::BLACK;
			else
				new_position.color_to_move = Color::WHITE;
			end if;
			select one engine related by self->Engine[R4];
			relate new_position to engine across R4;
			
			// link the new position in the tree
			relate new_position to self across R2.'follows' using move;
			
			return move;
			@endnoparse
		end operation;

	end class;

end;
